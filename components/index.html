<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="./style.css" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Doc</title>
  </head>
  <body>
  <section class="tsd-panel-group tsd-index-group" data-source-1536="">
  <section class="tsd-panel tsd-index-panel" data-source-1536="">
    <details class="tsd-index-content tsd-index-accordion" open data-source-1536="">
      <summary class="tsd-accordion-summary tsd-index-summary" data-source-1536="">
        <h5 class="tsd-index-heading uppercase" role="button" aria-expanded="false" tabIndex="0" data-source-1536=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" data-source-1536="">
            <path d="M1.5 5.50969L8 11.6609L14.5 5.50969L12.5466 3.66086L8 7.96494L3.45341 3.66086L1.5 5.50969Z" fill="var(--color-text)" data-source-1536=""></path>
          </svg> Index</h5>
      </summary>
      <div class="tsd-accordion-details" data-source-1536="">
        <section class="tsd-index-section" data-source-1536="">
          <h3 class="tsd-index-heading" data-source-1536="">Interfaces</h3>
          <div class="tsd-index-list" data-source-1536=""><a href="" class="tsd-index-link" data-source-1536=""><svg class="tsd-kind-icon" viewBox="0 0 24 24" data-source-1536="">
                <rect fill="var(--color-icon-background)" stroke="var(--color-ts-interface)" stroke-width="1.5" x="1" y="1" width="22" height="22" rx="6" data-source-1536=""></rect>
                <path d="M9.51 16V15.016H11.298V8.224H9.51V7.24H14.19V8.224H12.402V15.016H14.19V16H9.51Z" fill="var(--color-text)" data-source-1536=""></path>
              </svg><span data-source-1536="">Resize<wbr data-source-1536=""></wbr>Props</span></a>
          </div>
        </section>
        <section class="tsd-index-section" data-source-1536="">
          <h3 class="tsd-index-heading" data-source-1536="">Functions</h3>
          <div class="tsd-index-list" data-source-1536=""><a href="" class="tsd-index-link" data-source-1536=""><svg class="tsd-kind-icon" viewBox="0 0 24 24" data-source-1536="">
                <rect fill="var(--color-icon-background)" stroke="var(--color-ts-function)" stroke-width="1.5" x="1" y="1" width="22" height="22" rx="6" data-source-1536=""></rect>
                <path d="M9.39 16V7.24H14.55V8.224H10.446V11.128H14.238V12.112H10.47V16H9.39Z" fill="var(--color-text)" data-source-1536=""></path>
              </svg><span data-source-1536="">Stretch<wbr data-source-1536=""></wbr>Resize2</span></a>
            <a href="" class="tsd-index-link" data-source-1536=""><svg class="tsd-kind-icon" viewBox="0 0 24 24" data-source-1536="">
                <rect fill="var(--color-icon-background)" stroke="var(--color-ts-function)" stroke-width="1.5" x="1" y="1" width="22" height="22" rx="6" data-source-1536=""></rect>
                <path d="M9.39 16V7.24H14.55V8.224H10.446V11.128H14.238V12.112H10.47V16H9.39Z" fill="var(--color-text)" data-source-1536=""></path>
              </svg><span data-source-1536="">default</span></a>
          </div>
        </section>
      </div>
    </details>
  </section>
</section>
<section class="tsd-panel-group tsd-member-group" data-source-1536="">
  <h2 data-source-1536="">Interfaces</h2>
  <section class="tsd-panel tsd-member" data-source-1536=""><a class="tsd-anchor" data-source-1536=""></a>
    <h3 class="tsd-anchor-link" data-source-1536=""><span data-source-1536="">Resize<wbr data-source-1536=""></wbr>Props</span></h3>
    <div class="tsd-signature" data-source-1536=""><span class="tsd-kind-interface" data-source-1536="">Resize<wbr data-source-1536=""></wbr>Props</span></div>
    <div class="tsd-comment tsd-typography" data-source-1536="">sxx</div>
    <div class="tsd-comment tsd-typography" data-source-1536=""></div>
    <aside class="tsd-sources" data-source-1536="">
      <ul data-source-1536=""></ul>
    </aside>
    <section class="tsd-panel tsd-member" data-source-1536=""><a class="tsd-anchor" data-source-1536=""></a>
      <h3 class="tsd-anchor-link" data-source-1536=""><code class="tsd-tag ts-flagOptional" data-source-1536="">Optional</code> <code class="tsd-tag ts-flagReadonly" data-source-1536="">Readonly</code> <span data-source-1536="">children</span></h3>
      <div class="tsd-signature" data-source-1536=""><span class="tsd-kind-property" data-source-1536="">children</span><span class="tsd-signature-symbol" data-source-1536="">?:</span> <span class="tsd-signature-type" data-source-1536="">React.ReactNode</span></div>
      <aside class="tsd-sources" data-source-1536="">
        <ul data-source-1536=""></ul>
      </aside>
    </section>
    <section class="tsd-panel tsd-member" data-source-1536=""><a class="tsd-anchor" data-source-1536=""></a>
      <h3 class="tsd-anchor-link" data-source-1536=""><code class="tsd-tag ts-flagOptional" data-source-1536="">Optional</code> <span data-source-1536="">class<wbr data-source-1536=""></wbr>Name</span></h3>
      <div class="tsd-signature" data-source-1536=""><span class="tsd-kind-property" data-source-1536="">class<wbr data-source-1536=""></wbr>Name</span><span class="tsd-signature-symbol" data-source-1536="">?:</span> <span class="tsd-signature-type" data-source-1536="">string</span></div>
      <div class="tsd-comment tsd-typography" data-source-1536="">类名称</div>
      <div class="tsd-comment tsd-typography" data-source-1536=""></div>
      <aside class="tsd-sources" data-source-1536="">
        <ul data-source-1536=""></ul>
      </aside>
    </section>
    <section class="tsd-panel tsd-member" data-source-1536=""><a class="tsd-anchor" data-source-1536=""></a>
      <h3 class="tsd-anchor-link" data-source-1536=""><code class="tsd-tag ts-flagOptional" data-source-1536="">Optional</code> <span data-source-1536="">is</span></h3>
      <div class="tsd-signature" data-source-1536=""><span class="tsd-kind-property" data-source-1536="">is</span><span class="tsd-signature-symbol" data-source-1536="">?:</span> <span class="tsd-signature-type" data-source-1536="">string</span></div>
      <div class="tsd-comment tsd-typography" data-source-1536="">最外面包裹的元素默认是div</div>
      <div class="tsd-comment tsd-typography" data-source-1536=""></div>
      <aside class="tsd-sources" data-source-1536="">
        <ul data-source-1536=""></ul>
      </aside>
    </section>
    <section class="tsd-panel tsd-member" data-source-1536=""><a class="tsd-anchor" data-source-1536=""></a>
      <h3 class="tsd-anchor-link" data-source-1536=""><code class="tsd-tag ts-flagOptional" data-source-1536="">Optional</code> <span data-source-1536="">min<wbr data-source-1536=""></wbr>Size</span></h3>
      <div class="tsd-signature" data-source-1536=""><span class="tsd-kind-property" data-source-1536="">min<wbr data-source-1536=""></wbr>Size</span><span class="tsd-signature-symbol" data-source-1536="">?:</span> <span class="tsd-signature-type" data-source-1536="">number</span><span class="tsd-signature-symbol" data-source-1536=""> | </span><span class="tsd-signature-type" data-source-1536="">Partial</span><span class="tsd-signature-symbol" data-source-1536="">&lt;</span><span class="tsd-signature-type" data-source-1536="">MinSize</span><span class="tsd-signature-symbol" data-source-1536="">&gt;</span></div>
      <div class="tsd-comment tsd-typography" data-source-1536="">宽度和高度的最小值</div>
      <div class="tsd-comment tsd-typography" data-source-1536=""></div>
      <aside class="tsd-sources" data-source-1536="">
        <ul data-source-1536=""></ul>
      </aside>
    </section>
    <section class="tsd-panel tsd-member" data-source-1536=""><a class="tsd-anchor" data-source-1536=""></a>
      <h3 class="tsd-anchor-link" data-source-1536=""><code class="tsd-tag ts-flagOptional" data-source-1536="">Optional</code> <span data-source-1536="">on<wbr data-source-1536=""></wbr>Resize<wbr data-source-1536=""></wbr>End</span></h3>
      <div class="tsd-signature" data-source-1536=""><span class="tsd-kind-property" data-source-1536="">on<wbr data-source-1536=""></wbr>Resize<wbr data-source-1536=""></wbr>End</span><span class="tsd-signature-symbol" data-source-1536="">?:</span> <span class="tsd-signature-type" data-source-1536="">ResizeEnd</span><span class="tsd-signature-symbol" data-source-1536="">&lt;</span><span class="tsd-signature-type" data-source-1536="">void</span><span class="tsd-signature-symbol" data-source-1536="">&gt;</span></div>
      <div class="tsd-comment tsd-typography" data-source-1536="">调整尺寸完成后的回调</div>
      <div class="tsd-comment tsd-typography" data-source-1536=""></div>
      <aside class="tsd-sources" data-source-1536="">
        <ul data-source-1536=""></ul>
      </aside>
    </section>
    <section class="tsd-panel tsd-member" data-source-1536=""><a class="tsd-anchor" data-source-1536=""></a>
      <h3 class="tsd-anchor-link" data-source-1536=""><code class="tsd-tag ts-flagOptional" data-source-1536="">Optional</code> <span data-source-1536="">style</span></h3>
      <div class="tsd-signature" data-source-1536=""><span class="tsd-kind-property" data-source-1536="">style</span><span class="tsd-signature-symbol" data-source-1536="">?:</span> <span class="tsd-signature-type" data-source-1536="">React.CSSProperties</span></div>
      <div class="tsd-comment tsd-typography" data-source-1536="">内联样式</div>
      <div class="tsd-comment tsd-typography" data-source-1536=""></div>
      <aside class="tsd-sources" data-source-1536="">
        <ul data-source-1536=""></ul>
      </aside>
    </section>
    <section class="tsd-panel tsd-member" data-source-1536=""><a class="tsd-anchor" data-source-1536=""></a>
      <h3 class="tsd-anchor-link" data-source-1536=""><code class="tsd-tag ts-flagOptional" data-source-1536="">Optional</code> <span data-source-1536="">type</span></h3>
      <div class="tsd-signature" data-source-1536=""><span class="tsd-kind-property" data-source-1536="">type</span><span class="tsd-signature-symbol" data-source-1536="">?:</span> <span class="tsd-signature-type" data-source-1536="">ResizeType</span><span class="tsd-signature-symbol" data-source-1536=""> | </span><span class="tsd-signature-type" data-source-1536="">ResizeType</span><span class="tsd-signature-symbol" data-source-1536="">[]</span><span class="tsd-signature-symbol" data-source-1536=""> | </span><span class="tsd-signature-type" data-source-1536="">&quot;all&quot;</span></div>
      <div class="tsd-comment tsd-typography" data-source-1536="">哪些边允许调整</div>
      <div class="tsd-comment tsd-typography" data-source-1536=""></div>
      <aside class="tsd-sources" data-source-1536="">
        <ul data-source-1536=""></ul>
      </aside>
    </section>
  </section>
</section>
<section class="tsd-panel-group tsd-member-group" data-source-1536="">
  <h2 data-source-1536="">Functions</h2>
  <section class="tsd-panel tsd-member" data-source-1536=""><a class="tsd-anchor" data-source-1536=""></a>
    <h3 class="tsd-anchor-link" data-source-1536=""><span data-source-1536="">Stretch<wbr data-source-1536=""></wbr>Resize2</span></h3>
    <ul class="tsd-signatures" data-source-1536="">
      <li class="tsd-signature tsd-anchor-link" data-source-1536=""><a class="tsd-anchor" data-source-1536=""></a><span class="tsd-kind-call-signature" data-source-1536="">Stretch<wbr data-source-1536=""></wbr>Resize2</span><span class="tsd-signature-symbol" data-source-1536="">(</span><span class="tsd-kind-parameter" data-source-1536="">props</span>, <span class="tsd-kind-parameter" data-source-1536="">context</span><span class="tsd-signature-symbol" data-source-1536="">?</span><span class="tsd-signature-symbol" data-source-1536="">)</span><span class="tsd-signature-symbol" data-source-1536="">: </span><span class="tsd-signature-type" data-source-1536="">React.ReactNode</span></li>
      <li class="tsd-description" data-source-1536="">
        <div class="tsd-parameters" data-source-1536="">
          <h4 class="tsd-parameters-title" data-source-1536="">Parameters</h4>
          <ul class="tsd-parameter-list" data-source-1536="">
            <li data-source-1536=""><span data-source-1536=""><span class="tsd-kind-parameter" data-source-1536="">props</span>: <a href="" class="tsd-signature-type tsd-kind-interface" data-source-1536="">ResizeProps</a></span></li>
            <li data-source-1536=""><span data-source-1536=""><code class="tsd-tag ts-flagOptional" data-source-1536="">Optional</code> <span class="tsd-kind-parameter" data-source-1536="">context</span>: <span class="tsd-signature-type" data-source-1536="">any</span></span></li>
          </ul>
        </div>
        <h4 class="tsd-returns-title" data-source-1536="">Returns <span class="tsd-signature-type" data-source-1536="">React.ReactNode</span></h4>
        <aside class="tsd-sources" data-source-1536="">
          <ul data-source-1536=""></ul>
        </aside>
      </li>
    </ul>
  </section>
  <section class="tsd-panel tsd-member" data-source-1536=""><a class="tsd-anchor" data-source-1536=""></a>
    <h3 class="tsd-anchor-link" data-source-1536=""><span data-source-1536="">Stretch<wbr data-source-1536=""></wbr>Resize</span></h3>
    <ul class="tsd-signatures" data-source-1536="">
      <li class="tsd-signature tsd-anchor-link" data-source-1536=""><a class="tsd-anchor" data-source-1536=""></a><span class="tsd-kind-call-signature" data-source-1536="">Stretch<wbr data-source-1536=""></wbr>Resize</span><span class="tsd-signature-symbol" data-source-1536="">(</span><span class="tsd-kind-parameter" data-source-1536="">props</span>, <span class="tsd-kind-parameter" data-source-1536="">context</span><span class="tsd-signature-symbol" data-source-1536="">?</span><span class="tsd-signature-symbol" data-source-1536="">)</span><span class="tsd-signature-symbol" data-source-1536="">: </span><span class="tsd-signature-type" data-source-1536="">React.ReactNode</span></li>
      <li class="tsd-description" data-source-1536="">
        <div class="tsd-comment tsd-typography" data-source-1536="">调整元素的宽高</div>
        <div class="tsd-parameters" data-source-1536="">
          <h4 class="tsd-parameters-title" data-source-1536="">Parameters</h4>
          <ul class="tsd-parameter-list" data-source-1536="">
            <li data-source-1536=""><span data-source-1536=""><span class="tsd-kind-parameter" data-source-1536="">props</span>: <a href="" class="tsd-signature-type tsd-kind-interface" data-source-1536="">ResizeProps</a></span></li>
            <li data-source-1536=""><span data-source-1536=""><code class="tsd-tag ts-flagOptional" data-source-1536="">Optional</code> <span class="tsd-kind-parameter" data-source-1536="">context</span>: <span class="tsd-signature-type" data-source-1536="">any</span></span></li>
          </ul>
        </div>
        <h4 class="tsd-returns-title" data-source-1536="">Returns <span class="tsd-signature-type" data-source-1536="">React.ReactNode</span></h4>
        <div class="tsd-comment tsd-typography" data-source-1536=""></div>
        <aside class="tsd-sources" data-source-1536="">
          <ul data-source-1536=""></ul>
        </aside>
      </li>
    </ul>
  </section>
</section>
  </body>
  <script>
  "use strict";
  (() => {
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
      enumerable: true,
      configurable: true,
      writable: true,
      value
    }) : obj[key] = value;
    var __commonJS = (cb, mod) => function __require() {
      return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
        exports: {}
      }).exports, mod), mod.exports;
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, {
              get: () => from[key],
              enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
            });
      }
      return to;
    };
    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
      }) : target,
      mod
    ));
    var __publicField = (obj, key, value) => {
      __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };

    // node_modules/querystring/decode.js
    var require_decode = __commonJS({
      "node_modules/querystring/decode.js"(exports, module) {
        "use strict";

        function hasOwnProperty(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        }
        module.exports = function(qs, sep, eq, options) {
          sep = sep || "&";
          eq = eq || "=";
          var obj = {};
          if (typeof qs !== "string" || qs.length === 0) {
            return obj;
          }
          var regexp = /\+/g;
          qs = qs.split(sep);
          var maxKeys = 1e3;
          if (options && typeof options.maxKeys === "number") {
            maxKeys = options.maxKeys;
          }
          var len = qs.length;
          if (maxKeys > 0 && len > maxKeys) {
            len = maxKeys;
          }
          for (var i = 0; i < len; ++i) {
            var x = qs[i].replace(regexp, "%20"),
              idx = x.indexOf(eq),
              kstr, vstr, k, v;
            if (idx >= 0) {
              kstr = x.substr(0, idx);
              vstr = x.substr(idx + 1);
            } else {
              kstr = x;
              vstr = "";
            }
            k = decodeURIComponent(kstr);
            v = decodeURIComponent(vstr);
            if (!hasOwnProperty(obj, k)) {
              obj[k] = v;
            } else if (Array.isArray(obj[k])) {
              obj[k].push(v);
            } else {
              obj[k] = [obj[k], v];
            }
          }
          return obj;
        };
      }
    });

    // node_modules/querystring/encode.js
    var require_encode = __commonJS({
      "node_modules/querystring/encode.js"(exports, module) {
        "use strict";
        var stringifyPrimitive = function(v) {
          switch (typeof v) {
            case "string":
              return v;
            case "boolean":
              return v ? "true" : "false";
            case "number":
              return isFinite(v) ? v : "";
            default:
              return "";
          }
        };
        module.exports = function(obj, sep, eq, name) {
          sep = sep || "&";
          eq = eq || "=";
          if (obj === null) {
            obj = void 0;
          }
          if (typeof obj === "object") {
            return Object.keys(obj).map(function(k) {
              var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
              if (Array.isArray(obj[k])) {
                return obj[k].map(function(v) {
                  return ks + encodeURIComponent(stringifyPrimitive(v));
                }).join(sep);
              } else {
                return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
              }
            }).filter(Boolean).join(sep);
          }
          if (!name)
            return "";
          return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
        };
      }
    });

    // node_modules/querystring/index.js
    var require_querystring = __commonJS({
      "node_modules/querystring/index.js"(exports) {
        "use strict";
        exports.decode = exports.parse = require_decode();
        exports.encode = exports.stringify = require_encode();
      }
    });

    // node_modules/hotkeys-js/dist/hotkeys.esm.js
    var isff = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false;

    function addEvent(object, event, method, useCapture) {
      if (object.addEventListener) {
        object.addEventListener(event, method, useCapture);
      } else if (object.attachEvent) {
        object.attachEvent("on".concat(event), method);
      }
    }

    function removeEvent(object, event, method, useCapture) {
      if (object.removeEventListener) {
        object.removeEventListener(event, method, useCapture);
      } else if (object.detachEvent) {
        object.detachEvent("on".concat(event), method);
      }
    }

    function getMods(modifier, key) {
      const mods = key.slice(0, key.length - 1);
      for (let i = 0; i < mods.length; i++)
        mods[i] = modifier[mods[i].toLowerCase()];
      return mods;
    }

    function getKeys(key) {
      if (typeof key !== "string")
        key = "";
      key = key.replace(/\s/g, "");
      const keys = key.split(",");
      let index = keys.lastIndexOf("");
      for (; index >= 0;) {
        keys[index - 1] += ",";
        keys.splice(index, 1);
        index = keys.lastIndexOf("");
      }
      return keys;
    }

    function compareArray(a1, a2) {
      const arr1 = a1.length >= a2.length ? a1 : a2;
      const arr2 = a1.length >= a2.length ? a2 : a1;
      let isIndex = true;
      for (let i = 0; i < arr1.length; i++) {
        if (arr2.indexOf(arr1[i]) === -1)
          isIndex = false;
      }
      return isIndex;
    }
    var _keyMap = {
      backspace: 8,
      "\u232B": 8,
      tab: 9,
      clear: 12,
      enter: 13,
      "\u21A9": 13,
      return: 13,
      esc: 27,
      escape: 27,
      space: 32,
      left: 37,
      up: 38,
      right: 39,
      down: 40,
      del: 46,
      delete: 46,
      ins: 45,
      insert: 45,
      home: 36,
      end: 35,
      pageup: 33,
      pagedown: 34,
      capslock: 20,
      num_0: 96,
      num_1: 97,
      num_2: 98,
      num_3: 99,
      num_4: 100,
      num_5: 101,
      num_6: 102,
      num_7: 103,
      num_8: 104,
      num_9: 105,
      num_multiply: 106,
      num_add: 107,
      num_enter: 108,
      num_subtract: 109,
      num_decimal: 110,
      num_divide: 111,
      "\u21EA": 20,
      ",": 188,
      ".": 190,
      "/": 191,
      "`": 192,
      "-": isff ? 173 : 189,
      "=": isff ? 61 : 187,
      ";": isff ? 59 : 186,
      "'": 222,
      "[": 219,
      "]": 221,
      "\\": 220
    };
    var _modifier = {
      "\u21E7": 16,
      shift: 16,
      "\u2325": 18,
      alt: 18,
      option: 18,
      "\u2303": 17,
      ctrl: 17,
      control: 17,
      "\u2318": 91,
      cmd: 91,
      command: 91
    };
    var modifierMap = {
      16: "shiftKey",
      18: "altKey",
      17: "ctrlKey",
      91: "metaKey",
      shiftKey: 16,
      ctrlKey: 17,
      altKey: 18,
      metaKey: 91
    };
    var _mods = {
      16: false,
      18: false,
      17: false,
      91: false
    };
    var _handlers = {};
    for (let k = 1; k < 20; k++) {
      _keyMap["f".concat(k)] = 111 + k;
    }
    var _downKeys = [];
    var winListendFocus = null;
    var _scope = "all";
    var elementEventMap = /* @__PURE__ */ new Map();
    var code = (x) => _keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);
    var getKey = (x) => Object.keys(_keyMap).find((k) => _keyMap[k] === x);
    var getModifier = (x) => Object.keys(_modifier).find((k) => _modifier[k] === x);

    function setScope(scope) {
      _scope = scope || "all";
    }

    function getScope() {
      return _scope || "all";
    }

    function getPressedKeyCodes() {
      return _downKeys.slice(0);
    }

    function getPressedKeyString() {
      return _downKeys.map((c) => getKey(c) || getModifier(c) || String.fromCharCode(c));
    }

    function getAllKeyCodes() {
      const result = [];
      Object.keys(_handlers).forEach((k) => {
        _handlers[k].forEach((_ref) => {
          let {
            key,
            scope,
            mods,
            shortcut
          } = _ref;
          result.push({
            scope,
            shortcut,
            mods,
            keys: key.split("+").map((v) => code(v))
          });
        });
      });
      return result;
    }

    function filter(event) {
      const target = event.target || event.srcElement;
      const {
        tagName
      } = target;
      let flag = true;
      const isInput = tagName === "INPUT" && !["checkbox", "radio", "range", "button", "file", "reset", "submit", "color"].includes(target.type);
      if (target.isContentEditable || (isInput || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly) {
        flag = false;
      }
      return flag;
    }

    function isPressed(keyCode) {
      if (typeof keyCode === "string") {
        keyCode = code(keyCode);
      }
      return _downKeys.indexOf(keyCode) !== -1;
    }

    function deleteScope(scope, newScope) {
      let handlers;
      let i;
      if (!scope)
        scope = getScope();
      for (const key in _handlers) {
        if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
          handlers = _handlers[key];
          for (i = 0; i < handlers.length;) {
            if (handlers[i].scope === scope) {
              const deleteItems = handlers.splice(i, 1);
              deleteItems.forEach((_ref2) => {
                let {
                  element
                } = _ref2;
                return removeKeyEvent(element);
              });
            } else {
              i++;
            }
          }
        }
      }
      if (getScope() === scope)
        setScope(newScope || "all");
    }

    function clearModifier(event) {
      let key = event.keyCode || event.which || event.charCode;
      const i = _downKeys.indexOf(key);
      if (i >= 0) {
        _downKeys.splice(i, 1);
      }
      if (event.key && event.key.toLowerCase() === "meta") {
        _downKeys.splice(0, _downKeys.length);
      }
      if (key === 93 || key === 224)
        key = 91;
      if (key in _mods) {
        _mods[key] = false;
        for (const k in _modifier)
          if (_modifier[k] === key)
            hotkeys[k] = false;
      }
    }

    function unbind(keysInfo) {
      if (typeof keysInfo === "undefined") {
        Object.keys(_handlers).forEach((key) => {
          Array.isArray(_handlers[key]) && _handlers[key].forEach((info) => eachUnbind(info));
          delete _handlers[key];
        });
        removeKeyEvent(null);
      } else if (Array.isArray(keysInfo)) {
        keysInfo.forEach((info) => {
          if (info.key)
            eachUnbind(info);
        });
      } else if (typeof keysInfo === "object") {
        if (keysInfo.key)
          eachUnbind(keysInfo);
      } else if (typeof keysInfo === "string") {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        let [scope, method] = args;
        if (typeof scope === "function") {
          method = scope;
          scope = "";
        }
        eachUnbind({
          key: keysInfo,
          scope,
          method,
          splitKey: "+"
        });
      }
    }
    var eachUnbind = (_ref3) => {
      let {
        key,
        scope,
        method,
        splitKey = "+"
      } = _ref3;
      const multipleKeys = getKeys(key);
      multipleKeys.forEach((originKey) => {
        const unbindKeys = originKey.split(splitKey);
        const len = unbindKeys.length;
        const lastKey = unbindKeys[len - 1];
        const keyCode = lastKey === "*" ? "*" : code(lastKey);
        if (!_handlers[keyCode])
          return;
        if (!scope)
          scope = getScope();
        const mods = len > 1 ? getMods(_modifier, unbindKeys) : [];
        const unbindElements = [];
        _handlers[keyCode] = _handlers[keyCode].filter((record) => {
          const isMatchingMethod = method ? record.method === method : true;
          const isUnbind = isMatchingMethod && record.scope === scope && compareArray(record.mods, mods);
          if (isUnbind)
            unbindElements.push(record.element);
          return !isUnbind;
        });
        unbindElements.forEach((element) => removeKeyEvent(element));
      });
    };

    function eventHandler(event, handler, scope, element) {
      if (handler.element !== element) {
        return;
      }
      let modifiersMatch;
      if (handler.scope === scope || handler.scope === "all") {
        modifiersMatch = handler.mods.length > 0;
        for (const y in _mods) {
          if (Object.prototype.hasOwnProperty.call(_mods, y)) {
            if (!_mods[y] && handler.mods.indexOf(+y) > -1 || _mods[y] && handler.mods.indexOf(+y) === -1) {
              modifiersMatch = false;
            }
          }
        }
        if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === "*") {
          handler.keys = [];
          handler.keys = handler.keys.concat(_downKeys);
          if (handler.method(event, handler) === false) {
            if (event.preventDefault)
              event.preventDefault();
            else
              event.returnValue = false;
            if (event.stopPropagation)
              event.stopPropagation();
            if (event.cancelBubble)
              event.cancelBubble = true;
          }
        }
      }
    }

    function dispatch(event, element) {
      const asterisk = _handlers["*"];
      let key = event.keyCode || event.which || event.charCode;
      if (!hotkeys.filter.call(this, event))
        return;
      if (key === 93 || key === 224)
        key = 91;
      if (_downKeys.indexOf(key) === -1 && key !== 229)
        _downKeys.push(key);
      ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach((keyName) => {
        const keyNum = modifierMap[keyName];
        if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {
          _downKeys.push(keyNum);
        } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {
          _downKeys.splice(_downKeys.indexOf(keyNum), 1);
        } else if (keyName === "metaKey" && event[keyName] && _downKeys.length === 3) {
          if (!(event.ctrlKey || event.shiftKey || event.altKey)) {
            _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));
          }
        }
      });
      if (key in _mods) {
        _mods[key] = true;
        for (const k in _modifier) {
          if (_modifier[k] === key)
            hotkeys[k] = true;
        }
        if (!asterisk)
          return;
      }
      for (const e in _mods) {
        if (Object.prototype.hasOwnProperty.call(_mods, e)) {
          _mods[e] = event[modifierMap[e]];
        }
      }
      if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState("AltGraph")) {
        if (_downKeys.indexOf(17) === -1) {
          _downKeys.push(17);
        }
        if (_downKeys.indexOf(18) === -1) {
          _downKeys.push(18);
        }
        _mods[17] = true;
        _mods[18] = true;
      }
      const scope = getScope();
      if (asterisk) {
        for (let i = 0; i < asterisk.length; i++) {
          if (asterisk[i].scope === scope && (event.type === "keydown" && asterisk[i].keydown || event.type === "keyup" && asterisk[i].keyup)) {
            eventHandler(event, asterisk[i], scope, element);
          }
        }
      }
      if (!(key in _handlers))
        return;
      const handlerKey = _handlers[key];
      const keyLen = handlerKey.length;
      for (let i = 0; i < keyLen; i++) {
        if (event.type === "keydown" && handlerKey[i].keydown || event.type === "keyup" && handlerKey[i].keyup) {
          if (handlerKey[i].key) {
            const record = handlerKey[i];
            const {
              splitKey
            } = record;
            const keyShortcut = record.key.split(splitKey);
            const _downKeysCurrent = [];
            for (let a = 0; a < keyShortcut.length; a++) {
              _downKeysCurrent.push(code(keyShortcut[a]));
            }
            if (_downKeysCurrent.sort().join("") === _downKeys.sort().join("")) {
              eventHandler(event, record, scope, element);
            }
          }
        }
      }
    }

    function hotkeys(key, option, method) {
      _downKeys = [];
      const keys = getKeys(key);
      let mods = [];
      let scope = "all";
      let element = document;
      let i = 0;
      let keyup = false;
      let keydown = true;
      let splitKey = "+";
      let capture = false;
      let single = false;
      if (method === void 0 && typeof option === "function") {
        method = option;
      }
      if (Object.prototype.toString.call(option) === "[object Object]") {
        if (option.scope)
          scope = option.scope;
        if (option.element)
          element = option.element;
        if (option.keyup)
          keyup = option.keyup;
        if (option.keydown !== void 0)
          keydown = option.keydown;
        if (option.capture !== void 0)
          capture = option.capture;
        if (typeof option.splitKey === "string")
          splitKey = option.splitKey;
        if (option.single === true)
          single = true;
      }
      if (typeof option === "string")
        scope = option;
      if (single)
        unbind(key, scope);
      for (; i < keys.length; i++) {
        key = keys[i].split(splitKey);
        mods = [];
        if (key.length > 1)
          mods = getMods(_modifier, key);
        key = key[key.length - 1];
        key = key === "*" ? "*" : code(key);
        if (!(key in _handlers))
          _handlers[key] = [];
        _handlers[key].push({
          keyup,
          keydown,
          scope,
          mods,
          shortcut: keys[i],
          method,
          key: keys[i],
          splitKey,
          element
        });
      }
      if (typeof element !== "undefined" && window) {
        if (!elementEventMap.has(element)) {
          const keydownListener = function() {
            let event = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
            return dispatch(event, element);
          };
          const keyupListenr = function() {
            let event = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
            dispatch(event, element);
            clearModifier(event);
          };
          elementEventMap.set(element, {
            keydownListener,
            keyupListenr,
            capture
          });
          addEvent(element, "keydown", keydownListener, capture);
          addEvent(element, "keyup", keyupListenr, capture);
        }
        if (!winListendFocus) {
          const listener = () => {
            _downKeys = [];
          };
          winListendFocus = {
            listener,
            capture
          };
          addEvent(window, "focus", listener, capture);
        }
      }
    }

    function trigger(shortcut) {
      let scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
      Object.keys(_handlers).forEach((key) => {
        const dataList = _handlers[key].filter((item) => item.scope === scope && item.shortcut === shortcut);
        dataList.forEach((data) => {
          if (data && data.method) {
            data.method();
          }
        });
      });
    }

    function removeKeyEvent(element) {
      const values = Object.values(_handlers).flat();
      const findindex = values.findIndex((_ref4) => {
        let {
          element: el
        } = _ref4;
        return el === element;
      });
      if (findindex < 0) {
        const {
          keydownListener,
          keyupListenr,
          capture
        } = elementEventMap.get(element) || {};
        if (keydownListener && keyupListenr) {
          removeEvent(element, "keyup", keyupListenr, capture);
          removeEvent(element, "keydown", keydownListener, capture);
          elementEventMap.delete(element);
        }
      }
      if (values.length <= 0 || elementEventMap.size <= 0) {
        const eventKeys = Object.keys(elementEventMap);
        eventKeys.forEach((el) => {
          const {
            keydownListener,
            keyupListenr,
            capture
          } = elementEventMap.get(el) || {};
          if (keydownListener && keyupListenr) {
            removeEvent(el, "keyup", keyupListenr, capture);
            removeEvent(el, "keydown", keydownListener, capture);
            elementEventMap.delete(el);
          }
        });
        elementEventMap.clear();
        Object.keys(_handlers).forEach((key) => delete _handlers[key]);
        if (winListendFocus) {
          const {
            listener,
            capture
          } = winListendFocus;
          removeEvent(window, "focus", listener, capture);
          winListendFocus = null;
        }
      }
    }
    var _api = {
      getPressedKeyString,
      setScope,
      getScope,
      deleteScope,
      getPressedKeyCodes,
      getAllKeyCodes,
      isPressed,
      filter,
      trigger,
      unbind,
      keyMap: _keyMap,
      modifier: _modifier,
      modifierMap
    };
    for (const a in _api) {
      if (Object.prototype.hasOwnProperty.call(_api, a)) {
        hotkeys[a] = _api[a];
      }
    }
    if (typeof window !== "undefined") {
      const _hotkeys = window.hotkeys;
      hotkeys.noConflict = (deep) => {
        if (deep && window.hotkeys === hotkeys) {
          window.hotkeys = _hotkeys;
        }
        return hotkeys;
      };
      window.hotkeys = hotkeys;
    }

    // src/render/inspector/utils/highlight.ts
    var iframesListeningTo = /* @__PURE__ */ new Set();

    function setupHighlighter(handlers) {
      function startInspectingNative() {
        registerListenersOnWindow(window);
      }

      function registerListenersOnWindow(window2) {
        if (window2 && typeof window2.addEventListener === "function") {
          window2.addEventListener("click", onClick, true);
          window2.addEventListener("mousedown", onMouseEvent, true);
          window2.addEventListener("mouseover", onMouseEvent, true);
          window2.addEventListener("mouseup", onMouseEvent, true);
          window2.addEventListener("pointerdown", onPointerDown, true);
          window2.addEventListener("pointerover", onPointerOver, true);
          window2.addEventListener("pointerup", onPointerUp, true);
        }
      }

      function stopInspectingNative() {
        removeListenersOnWindow(window);
        iframesListeningTo.forEach(function(frame) {
          try {
            removeListenersOnWindow(frame.contentWindow);
          } catch (error) {}
        });
        iframesListeningTo = /* @__PURE__ */ new Set();
      }

      function removeListenersOnWindow(window2) {
        if (window2 && typeof window2.removeEventListener === "function") {
          window2.removeEventListener("click", onClick, true);
          window2.removeEventListener("mousedown", onMouseEvent, true);
          window2.removeEventListener("mouseover", onMouseEvent, true);
          window2.removeEventListener("mouseup", onMouseEvent, true);
          window2.removeEventListener("pointerdown", onPointerDown, true);
          window2.removeEventListener("pointerover", onPointerOver, true);
          window2.removeEventListener("pointerup", onPointerUp, true);
        }
      }

      function onClick(event) {
        event.preventDefault();
        event.stopPropagation();
        stopInspectingNative();
        handlers.onClick?.(event.target);
      }

      function onMouseEvent(event) {
        event.preventDefault();
        event.stopPropagation();
      }

      function onPointerDown(event) {
        event.preventDefault();
        event.stopPropagation();
      }

      function onPointerOver(event) {
        event.preventDefault();
        event.stopPropagation();
        const target = event.target;
        if (target.tagName === "IFRAME") {
          const iframe = target;
          try {
            if (!iframesListeningTo.has(iframe)) {
              const window2 = iframe.contentWindow;
              registerListenersOnWindow(window2);
              iframesListeningTo.add(iframe);
            }
          } catch (error) {}
        }
        handlers.onPointerOver?.(event.target);
      }

      function onPointerUp(event) {
        event.preventDefault();
        event.stopPropagation();
      }
      startInspectingNative();
      return stopInspectingNative;
    }

    // src/render/inspector/utils/inspect.ts
    var import_querystring = __toESM(require_querystring(), 1);

    // src/render/inspector/utils/fiber.ts
    var isNativeTagFiber = (fiber) => typeof fiber?.type === "string";
    var isReactSymbolFiber = (fiber) => typeof fiber?.type?.$typeof === "symbol";
    var isForwardRef = (fiber) => fiber?.type?.$typeof === Symbol.for("react.forward_ref");
    var getElementFiber = (element) => {
      const fiberKey = Object.keys(element.dataset).find((key) => key.startsWith("source-"));
      if (fiberKey) {
        const source = window.debug[`data-${fiberKey}`].__source;
        return {
          pendingProps: source ? {
            "data-inspector-line": source.lineNumber,
            "data-inspector-column": source.columnNumber,
            "data-inspector-relative-path": source.fileName
          } : void 0,
          _debugSource: source
        };
      }
      return void 0;
    };
    var getElementFiberUpward = (element) => {
      if (!element)
        return void 0;
      const fiber = getElementFiber(element);
      if (fiber)
        return fiber;
      return getElementFiberUpward(element.parentElement);
    };
    var getDirectParentFiber = (child) => {
      let current = child.return;
      while (current) {
        if (!isReactSymbolFiber(current)) {
          return current;
        }
        current = current.return;
      }
      return null;
    };
    var getFiberName = (fiber) => {
      const fiberType = fiber?.type;
      if (!fiberType)
        return void 0;
      const {
        displayName,
        name
      } = fiberType;
      if (typeof displayName === "string") {
        return displayName;
      } else if (typeof name === "string") {
        return name;
      }
      return void 0;
    };

    // src/render/inspector/utils/inspect.ts
    var getCodeInfoFromDebugSource = (fiber) => {
      if (!fiber?._debugSource)
        return void 0;
      const {
        fileName,
        lineNumber,
        columnNumber
      } = fiber._debugSource;
      if (fileName && lineNumber) {
        return {
          lineNumber: String(lineNumber),
          columnNumber: String(columnNumber ?? 1),
          absolutePath: fileName.match(/^<.*>$/) ? fileName.replace(/^<|>$/g, "") : fileName
        };
      }
      return void 0;
    };
    var getCodeInfoFromProps = (fiber) => {
      if (!fiber?.pendingProps)
        return void 0;
      const {
        "data-inspector-line": lineNumber,
        "data-inspector-column": columnNumber,
        "data-inspector-relative-path": relativePath
      } = fiber.pendingProps;
      if (lineNumber && columnNumber && relativePath) {
        return {
          lineNumber,
          columnNumber,
          relativePath
        };
      }
      return void 0;
    };
    var getCodeInfoFromFiber = (fiber) => getCodeInfoFromProps(fiber) ?? getCodeInfoFromDebugSource(fiber);
    var getReferenceFiber = (baseFiber) => {
      if (!baseFiber)
        return void 0;
      const directParent = getDirectParentFiber(baseFiber);
      if (!directParent)
        return void 0;
      const isParentNative = isNativeTagFiber(directParent);
      const isOnlyOneChild = !directParent.child.sibling;
      let referenceFiber = !isParentNative && isOnlyOneChild ? directParent : baseFiber;
      const originReferenceFiber = referenceFiber;
      while (referenceFiber) {
        if (getCodeInfoFromFiber(referenceFiber))
          return referenceFiber;
        referenceFiber = referenceFiber.return;
      }
      return originReferenceFiber;
    };
    var getElementCodeInfo = (element) => {
      const fiber = getElementFiberUpward(element);
      return getCodeInfoFromFiber(fiber);
    };
    var gotoEditor = (source) => {
      if (!source)
        return;
      const {
        lineNumber,
        columnNumber,
        relativePath,
        absolutePath
      } = source;
      const isRelative = Boolean(relativePath);
      const launchParams = {
        file: (isRelative ? relativePath : absolutePath) + `:${lineNumber}:${columnNumber}`,
        lineNumber,
        colNumber: columnNumber
      };
      const apiRoute = isRelative ? `/__open-in-editor/relative` : `/__open-in-editor`;
      fetch(`${apiRoute}?${import_querystring.default.stringify(launchParams)}`);
    };
    var getNamedFiber = (baseFiber) => {
      let fiber = baseFiber;
      let originNamedFiber;
      while (fiber) {
        let parent = fiber.return ?? void 0;
        let forwardParent;
        while (isReactSymbolFiber(parent)) {
          if (isForwardRef(parent)) {
            forwardParent = parent;
          }
          parent = parent?.return ?? void 0;
        }
        if (forwardParent) {
          fiber = forwardParent;
        }
        if (getFiberName(fiber)) {
          if (!originNamedFiber)
            originNamedFiber = fiber;
          if (getCodeInfoFromFiber(fiber))
            return fiber;
        }
        fiber = parent;
      }
      return originNamedFiber;
    };
    var getElementInspect = (element) => {
      const fiber = getElementFiberUpward(element);
      const referenceFiber = getReferenceFiber(fiber);
      const namedFiber = getNamedFiber(referenceFiber);
      const fiberName = getFiberName(namedFiber);
      const nodeName = element.nodeName.toLowerCase();
      const title = fiberName ? `${nodeName} in <${fiberName}>` : nodeName;
      return {
        fiber: referenceFiber,
        name: fiberName,
        title
      };
    };

    // src/render/inspector/utils/overlay.ts
    function getNestedBoundingClientRect(node) {
      return node.getBoundingClientRect();
    }

    function getElementDimensions(domElement) {
      const calculatedStyle = window.getComputedStyle(domElement);
      return {
        borderLeft: parseInt(calculatedStyle.borderLeftWidth, 10),
        borderRight: parseInt(calculatedStyle.borderRightWidth, 10),
        borderTop: parseInt(calculatedStyle.borderTopWidth, 10),
        borderBottom: parseInt(calculatedStyle.borderBottomWidth, 10),
        marginLeft: parseInt(calculatedStyle.marginLeft, 10),
        marginRight: parseInt(calculatedStyle.marginRight, 10),
        marginTop: parseInt(calculatedStyle.marginTop, 10),
        marginBottom: parseInt(calculatedStyle.marginBottom, 10),
        paddingLeft: parseInt(calculatedStyle.paddingLeft, 10),
        paddingRight: parseInt(calculatedStyle.paddingRight, 10),
        paddingTop: parseInt(calculatedStyle.paddingTop, 10),
        paddingBottom: parseInt(calculatedStyle.paddingBottom, 10)
      };
    }

    // src/render/inspector/Overlay.tsx
    var OverlayRect = class {
      constructor(doc, container) {
        __publicField(this, "node");
        __publicField(this, "border");
        __publicField(this, "padding");
        __publicField(this, "content");
        this.node = doc.createElement("div");
        this.border = doc.createElement("div");
        this.padding = doc.createElement("div");
        this.content = doc.createElement("div");
        this.border.style.borderColor = overlayStyles.border;
        this.padding.style.borderColor = overlayStyles.padding;
        this.content.style.backgroundColor = overlayStyles.background;
        Object.assign(this.node.style, {
          borderColor: overlayStyles.margin,
          pointerEvents: "none",
          position: "fixed"
        });
        this.node.style.zIndex = "10000000";
        this.node.appendChild(this.border);
        this.border.appendChild(this.padding);
        this.padding.appendChild(this.content);
        container.prepend(this.node);
      }
      remove() {
        if (this.node.parentNode) {
          this.node.parentNode.removeChild(this.node);
        }
      }
      update(box, dims) {
        boxWrap(dims, "margin", this.node);
        boxWrap(dims, "border", this.border);
        boxWrap(dims, "padding", this.padding);
        Object.assign(this.content.style, {
          height: `${box.height - dims.borderTop - dims.borderBottom - dims.paddingTop - dims.paddingBottom}px`,
          width: `${box.width - dims.borderLeft - dims.borderRight - dims.paddingLeft - dims.paddingRight}px`
        });
        Object.assign(this.node.style, {
          top: `${box.top - dims.marginTop}px`,
          left: `${box.left - dims.marginLeft}px`
        });
      }
    };
    var OverlayTip = class {
      constructor(doc, container) {
        __publicField(this, "tip");
        __publicField(this, "nameSpan");
        __publicField(this, "titleDiv");
        __publicField(this, "infoDiv");
        __publicField(this, "dimSpan");
        this.tip = doc.createElement("div");
        Object.assign(this.tip.style, {
          display: "flex",
          flexFlow: "row nowrap",
          alignItems: "center",
          backgroundColor: "#333740",
          borderRadius: "2px",
          fontFamily: '"SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace',
          fontWeight: "bold",
          padding: "6px 8px",
          pointerEvents: "none",
          position: "fixed",
          fontSize: "12px",
          whiteSpace: "nowrap"
        });
        this.nameSpan = doc.createElement("span");
        this.tip.appendChild(this.nameSpan);
        Object.assign(this.nameSpan.style, {
          display: "flex",
          flexDirection: "column",
          borderRight: "1px solid #aaaaaa",
          paddingRight: "0.8rem",
          marginRight: "0.8rem"
        });
        this.titleDiv = doc.createElement("div");
        this.nameSpan.appendChild(this.titleDiv);
        Object.assign(this.titleDiv.style, {
          color: "#ee78e6",
          fontSize: "16px"
        });
        this.infoDiv = doc.createElement("div");
        this.nameSpan.appendChild(this.infoDiv);
        Object.assign(this.infoDiv.style, {
          color: "#ee78e6",
          fontSize: "14px"
        });
        this.dimSpan = doc.createElement("span");
        this.tip.appendChild(this.dimSpan);
        Object.assign(this.dimSpan.style, {
          color: "#d7d7d7"
        });
        this.tip.style.zIndex = "10000000";
        container.appendChild(this.tip);
      }
      remove() {
        if (this.tip.parentNode) {
          this.tip.parentNode.removeChild(this.tip);
        }
      }
      updateText(name, info, width, height) {
        this.titleDiv.textContent = name;
        this.infoDiv.textContent = info ?? "";
        this.dimSpan.textContent = `${Math.round(width)}px \xD7 ${Math.round(height)}px`;
      }
      updatePosition(dims, bounds) {
        const tipRect = this.tip.getBoundingClientRect();
        const tipPos = findTipPos(dims, bounds, {
          width: tipRect.width,
          height: tipRect.height
        });
        Object.assign(this.tip.style, tipPos.style);
      }
    };
    var Overlay = class {
      constructor() {
        __publicField(this, "window");
        __publicField(this, "tipBoundsWindow");
        __publicField(this, "container");
        __publicField(this, "tip");
        __publicField(this, "rects");
        __publicField(this, "removeCallback");
        const currentWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;
        this.window = currentWindow;
        const tipBoundsWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;
        this.tipBoundsWindow = tipBoundsWindow;
        const doc = currentWindow.document;
        this.container = doc.createElement("div");
        this.container.style.zIndex = "10000000";
        this.tip = new OverlayTip(doc, this.container);
        this.rects = [];
        this.removeCallback = () => {};
        doc.body.appendChild(this.container);
      }
      remove() {
        this.tip.remove();
        this.rects.forEach((rect) => {
          rect.remove();
        });
        this.rects.length = 0;
        if (this.container.parentNode) {
          this.container.parentNode.removeChild(this.container);
        }
        this.removeCallback();
      }
      setRemoveCallback(callback) {
        this.removeCallback = callback.bind(this);
      }
      inspect(nodes, name, info) {
        const elements = nodes.filter((node) => node.nodeType === Node.ELEMENT_NODE);
        while (this.rects.length > elements.length) {
          const rect = this.rects.pop();
          rect?.remove();
        }
        if (elements.length === 0) {
          return;
        }
        while (this.rects.length < elements.length) {
          this.rects.push(new OverlayRect(this.window.document, this.container));
        }
        const outerBox = {
          top: Number.POSITIVE_INFINITY,
          right: Number.NEGATIVE_INFINITY,
          bottom: Number.NEGATIVE_INFINITY,
          left: Number.POSITIVE_INFINITY
        };
        elements.forEach((element, index) => {
          const box = getNestedBoundingClientRect(element, this.window);
          const dims = getElementDimensions(element);
          outerBox.top = Math.min(outerBox.top, box.top - dims.marginTop);
          outerBox.right = Math.max(
            outerBox.right,
            box.left + box.width + dims.marginRight
          );
          outerBox.bottom = Math.max(
            outerBox.bottom,
            box.top + box.height + dims.marginBottom
          );
          outerBox.left = Math.min(outerBox.left, box.left - dims.marginLeft);
          const rect = this.rects[index];
          rect.update(box, dims);
        });
        if (!name) {
          name = elements[0].nodeName.toLowerCase();
          const node = elements[0];
          const hook = node.ownerDocument.defaultView?.__REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook?.rendererInterfaces) {
            let ownerName = null;
            for (const rendererInterface of hook.rendererInterfaces.values()) {
              const id = rendererInterface.getFiberIDForNative(node, true);
              if (id !== null) {
                ownerName = rendererInterface.getDisplayNameForFiberID(id, true);
                break;
              }
            }
            if (ownerName) {
              name += ` (in ${ownerName})`;
            }
          }
        }
        this.tip.updateText(
          name,
          info,
          outerBox.right - outerBox.left,
          outerBox.bottom - outerBox.top
        );
        const tipBounds = getNestedBoundingClientRect(
          this.tipBoundsWindow.document.documentElement,
          this.window
        );
        this.tip.updatePosition({
          top: outerBox.top,
          left: outerBox.left,
          height: outerBox.bottom - outerBox.top,
          width: outerBox.right - outerBox.left
        }, {
          top: tipBounds.top + this.tipBoundsWindow.scrollY,
          left: tipBounds.left + this.tipBoundsWindow.scrollX,
          height: this.tipBoundsWindow.innerHeight,
          width: this.tipBoundsWindow.innerWidth
        });
      }
    };

    function findTipPos(dims, bounds, tipSize) {
      const tipHeight = Math.max(tipSize.height, 20);
      const tipWidth = Math.max(tipSize.width, 60);
      const margin = 5;
      let top;
      if (dims.top + dims.height + tipHeight <= bounds.top + bounds.height) {
        if (dims.top + dims.height < bounds.top + 0) {
          top = bounds.top + margin;
        } else {
          top = dims.top + dims.height + margin;
        }
      } else if (dims.top - tipHeight <= bounds.top + bounds.height) {
        if (dims.top - tipHeight - margin < bounds.top + margin) {
          top = bounds.top + margin;
        } else {
          top = dims.top - tipHeight - margin;
        }
      } else {
        top = bounds.top + bounds.height - tipHeight - margin;
      }
      let left = dims.left + margin;
      if (dims.left < bounds.left) {
        left = bounds.left + margin;
      }
      if (dims.left + tipWidth > bounds.left + bounds.width) {
        left = bounds.left + bounds.width - tipWidth - margin;
      }
      return {
        style: {
          top: `${top}px`,
          left: `${left}px`
        }
      };
    }

    function boxWrap(dims, what, node) {
      Object.assign(node.style, {
        borderTopWidth: `${dims[`${what}Top`]}px`,
        borderLeftWidth: `${dims[`${what}Left`]}px`,
        borderRightWidth: `${dims[`${what}Right`]}px`,
        borderBottomWidth: `${dims[`${what}Bottom`]}px`,
        borderStyle: "solid"
      });
    }
    var overlayStyles = {
      background: "rgba(120, 170, 210, 0.7)",
      padding: "rgba(77, 200, 0, 0.3)",
      margin: "rgba(255, 155, 0, 0.3)",
      border: "rgba(255, 200, 50, 0.3)"
    };

    // src/render/inspector/mounted.ts
    function createRef(init) {
      return {
        current: init
      };
    }
    var defaultHotKeys = ["control", "shift", "command", "c"];
    var hotkey = defaultHotKeys.join("+");
    var overlayRef = createRef();
    var mousePointRef = createRef({
      x: 0,
      y: 0
    });
    var recordMousePoint = ({
      clientX,
      clientY
    }) => {
      mousePointRef.current.x = clientX;
      mousePointRef.current.y = clientY;
    };
    var startInspect = () => {
      const overlay = new Overlay();
      overlayRef.current = overlay;
      const stopCallback = setupHighlighter({
        onPointerOver: handleHoverElement,
        onClick: handleClickElement
      });
      overlay.setRemoveCallback(stopCallback);
      const initPoint = mousePointRef.current;
      const initElement = document.elementFromPoint(initPoint.x, initPoint.y);
      if (initElement)
        handleHoverElement(initElement);
    };
    var stopInspect = () => {
      overlayRef.current?.remove();
      overlayRef.current = void 0;
    };
    var handleHoverElement = (element) => {
      const overlay = overlayRef.current;
      const codeInfo = getElementCodeInfo(element);
      const relativePath = codeInfo?.relativePath;
      const absolutePath = codeInfo?.absolutePath;
      const {
        fiber,
        name,
        title
      } = getElementInspect(element);
      overlay?.inspect?.([element], title, relativePath ?? absolutePath);
      console.log("hover", fiber, name);
    };
    var handleClickElement = (element) => {
      stopInspect();
      const codeInfo = getElementCodeInfo(element);
      const {
        fiber,
        name
      } = getElementInspect(element);
      console.log("codeInfo", codeInfo);
      gotoEditor(codeInfo);
      console.log("hover", fiber, name);
    };
    document.addEventListener("mousemove", recordMousePoint, true);
    var handleHotKeys = (event, handler) => {
      if (handler.key === hotkey) {
        overlayRef.current ? stopInspect() : startInspect();
      } else if (handler.key === "esc" && overlayRef.current) {
        stopInspect();
      }
    };
    hotkeys(`${hotkey}, esc`, handleHotKeys);
    window.__REACT_DEV_INSPECTOR_TOGGLE__ = () => overlayRef.current ? stopInspect() : startInspect();
  })();;
  window.debug = {
    "data-source-1536": {
      "__source": {}
    }
  }
</script>
</html>
