    Doc

##### Index

### Interfaces

ResizeProps

### Functions

StretchResize2 default

Interfaces
----------

### ResizeProps

ResizeProps

sxx

### `Optional` `Readonly` children

children?: React.ReactNode

### `Optional` className

className?: string

类名称

### `Optional` is

is?: string

最外面包裹的元素默认是div

### `Optional` minSize

minSize?: number | Partial<MinSize\>

宽度和高度的最小值

### `Optional` onResizeEnd

onResizeEnd?: ResizeEnd<void\>

调整尺寸完成后的回调

### `Optional` style

style?: React.CSSProperties

内联样式

### `Optional` type

type?: ResizeType | ResizeType\[\] | "all"

哪些边允许调整

Functions
---------

### StretchResize2

*   StretchResize2(props, context?): React.ReactNode
*   #### Parameters
    
    *   props: ResizeProps
    *   `Optional` context: any
    
    #### Returns React.ReactNode
    

### StretchResize

*   StretchResize(props, context?): React.ReactNode
*   调整元素的宽高
    
    #### Parameters
    
    *   props: ResizeProps
    *   `Optional` context: any
    
    #### Returns React.ReactNode
    

"use strict"; (() => { var \_\_create = Object.create; var \_\_defProp = Object.defineProperty; var \_\_getOwnPropDesc = Object.getOwnPropertyDescriptor; var \_\_getOwnPropNames = Object.getOwnPropertyNames; var \_\_getProtoOf = Object.getPrototypeOf; var \_\_hasOwnProp = Object.prototype.hasOwnProperty; var \_\_defNormalProp = (obj, key, value) => key in obj ? \_\_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj\[key\] = value; var \_\_commonJS = (cb, mod) => function \_\_require() { return mod || (0, cb\[\_\_getOwnPropNames(cb)\[0\]\])((mod = { exports: {} }).exports, mod), mod.exports; }; var \_\_copyProps = (to, from, except, desc) => { if (from && typeof from === "object" || typeof from === "function") { for (let key of \_\_getOwnPropNames(from)) if (!\_\_hasOwnProp.call(to, key) && key !== except) \_\_defProp(to, key, { get: () => from\[key\], enumerable: !(desc = \_\_getOwnPropDesc(from, key)) || desc.enumerable }); } return to; }; var \_\_toESM = (mod, isNodeMode, target) => (target = mod != null ? \_\_create(\_\_getProtoOf(mod)) : {}, \_\_copyProps( isNodeMode || !mod || !mod.\_\_esModule ? \_\_defProp(target, "default", { value: mod, enumerable: true }) : target, mod )); var \_\_publicField = (obj, key, value) => { \_\_defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value); return value; }; // node\_modules/querystring/decode.js var require\_decode = \_\_commonJS({ "node\_modules/querystring/decode.js"(exports, module) { "use strict"; function hasOwnProperty(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); } module.exports = function(qs, sep, eq, options) { sep = sep || "&"; eq = eq || "="; var obj = {}; if (typeof qs !== "string" || qs.length === 0) { return obj; } var regexp = /\\+/g; qs = qs.split(sep); var maxKeys = 1e3; if (options && typeof options.maxKeys === "number") { maxKeys = options.maxKeys; } var len = qs.length; if (maxKeys > 0 && len > maxKeys) { len = maxKeys; } for (var i = 0; i < len; ++i) { var x = qs\[i\].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v; if (idx >= 0) { kstr = x.substr(0, idx); vstr = x.substr(idx + 1); } else { kstr = x; vstr = ""; } k = decodeURIComponent(kstr); v = decodeURIComponent(vstr); if (!hasOwnProperty(obj, k)) { obj\[k\] = v; } else if (Array.isArray(obj\[k\])) { obj\[k\].push(v); } else { obj\[k\] = \[obj\[k\], v\]; } } return obj; }; } }); // node\_modules/querystring/encode.js var require\_encode = \_\_commonJS({ "node\_modules/querystring/encode.js"(exports, module) { "use strict"; var stringifyPrimitive = function(v) { switch (typeof v) { case "string": return v; case "boolean": return v ? "true" : "false"; case "number": return isFinite(v) ? v : ""; default: return ""; } }; module.exports = function(obj, sep, eq, name) { sep = sep || "&"; eq = eq || "="; if (obj === null) { obj = void 0; } if (typeof obj === "object") { return Object.keys(obj).map(function(k) { var ks = encodeURIComponent(stringifyPrimitive(k)) + eq; if (Array.isArray(obj\[k\])) { return obj\[k\].map(function(v) { return ks + encodeURIComponent(stringifyPrimitive(v)); }).join(sep); } else { return ks + encodeURIComponent(stringifyPrimitive(obj\[k\])); } }).filter(Boolean).join(sep); } if (!name) return ""; return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj)); }; } }); // node\_modules/querystring/index.js var require\_querystring = \_\_commonJS({ "node\_modules/querystring/index.js"(exports) { "use strict"; exports.decode = exports.parse = require\_decode(); exports.encode = exports.stringify = require\_encode(); } }); // node\_modules/hotkeys-js/dist/hotkeys.esm.js var isff = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false; function addEvent(object, event, method, useCapture) { if (object.addEventListener) { object.addEventListener(event, method, useCapture); } else if (object.attachEvent) { object.attachEvent("on".concat(event), method); } } function removeEvent(object, event, method, useCapture) { if (object.removeEventListener) { object.removeEventListener(event, method, useCapture); } else if (object.detachEvent) { object.detachEvent("on".concat(event), method); } } function getMods(modifier, key) { const mods = key.slice(0, key.length - 1); for (let i = 0; i < mods.length; i++) mods\[i\] = modifier\[mods\[i\].toLowerCase()\]; return mods; } function getKeys(key) { if (typeof key !== "string") key = ""; key = key.replace(/\\s/g, ""); const keys = key.split(","); let index = keys.lastIndexOf(""); for (; index >= 0;) { keys\[index - 1\] += ","; keys.splice(index, 1); index = keys.lastIndexOf(""); } return keys; } function compareArray(a1, a2) { const arr1 = a1.length >= a2.length ? a1 : a2; const arr2 = a1.length >= a2.length ? a2 : a1; let isIndex = true; for (let i = 0; i < arr1.length; i++) { if (arr2.indexOf(arr1\[i\]) === -1) isIndex = false; } return isIndex; } var \_keyMap = { backspace: 8, "\\u232B": 8, tab: 9, clear: 12, enter: 13, "\\u21A9": 13, return: 13, esc: 27, escape: 27, space: 32, left: 37, up: 38, right: 39, down: 40, del: 46, delete: 46, ins: 45, insert: 45, home: 36, end: 35, pageup: 33, pagedown: 34, capslock: 20, num\_0: 96, num\_1: 97, num\_2: 98, num\_3: 99, num\_4: 100, num\_5: 101, num\_6: 102, num\_7: 103, num\_8: 104, num\_9: 105, num\_multiply: 106, num\_add: 107, num\_enter: 108, num\_subtract: 109, num\_decimal: 110, num\_divide: 111, "\\u21EA": 20, ",": 188, ".": 190, "/": 191, "\`": 192, "-": isff ? 173 : 189, "=": isff ? 61 : 187, ";": isff ? 59 : 186, "'": 222, "\[": 219, "\]": 221, "\\\\": 220 }; var \_modifier = { "\\u21E7": 16, shift: 16, "\\u2325": 18, alt: 18, option: 18, "\\u2303": 17, ctrl: 17, control: 17, "\\u2318": 91, cmd: 91, command: 91 }; var modifierMap = { 16: "shiftKey", 18: "altKey", 17: "ctrlKey", 91: "metaKey", shiftKey: 16, ctrlKey: 17, altKey: 18, metaKey: 91 }; var \_mods = { 16: false, 18: false, 17: false, 91: false }; var \_handlers = {}; for (let k = 1; k < 20; k++) { \_keyMap\["f".concat(k)\] = 111 + k; } var \_downKeys = \[\]; var winListendFocus = null; var \_scope = "all"; var elementEventMap = /\* @\_\_PURE\_\_ \*/ new Map(); var code = (x) => \_keyMap\[x.toLowerCase()\] || \_modifier\[x.toLowerCase()\] || x.toUpperCase().charCodeAt(0); var getKey = (x) => Object.keys(\_keyMap).find((k) => \_keyMap\[k\] === x); var getModifier = (x) => Object.keys(\_modifier).find((k) => \_modifier\[k\] === x); function setScope(scope) { \_scope = scope || "all"; } function getScope() { return \_scope || "all"; } function getPressedKeyCodes() { return \_downKeys.slice(0); } function getPressedKeyString() { return \_downKeys.map((c) => getKey(c) || getModifier(c) || String.fromCharCode(c)); } function getAllKeyCodes() { const result = \[\]; Object.keys(\_handlers).forEach((k) => { \_handlers\[k\].forEach((\_ref) => { let { key, scope, mods, shortcut } = \_ref; result.push({ scope, shortcut, mods, keys: key.split("+").map((v) => code(v)) }); }); }); return result; } function filter(event) { const target = event.target || event.srcElement; const { tagName } = target; let flag = true; const isInput = tagName === "INPUT" && !\["checkbox", "radio", "range", "button", "file", "reset", "submit", "color"\].includes(target.type); if (target.isContentEditable || (isInput || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly) { flag = false; } return flag; } function isPressed(keyCode) { if (typeof keyCode === "string") { keyCode = code(keyCode); } return \_downKeys.indexOf(keyCode) !== -1; } function deleteScope(scope, newScope) { let handlers; let i; if (!scope) scope = getScope(); for (const key in \_handlers) { if (Object.prototype.hasOwnProperty.call(\_handlers, key)) { handlers = \_handlers\[key\]; for (i = 0; i < handlers.length;) { if (handlers\[i\].scope === scope) { const deleteItems = handlers.splice(i, 1); deleteItems.forEach((\_ref2) => { let { element } = \_ref2; return removeKeyEvent(element); }); } else { i++; } } } } if (getScope() === scope) setScope(newScope || "all"); } function clearModifier(event) { let key = event.keyCode || event.which || event.charCode; const i = \_downKeys.indexOf(key); if (i >= 0) { \_downKeys.splice(i, 1); } if (event.key && event.key.toLowerCase() === "meta") { \_downKeys.splice(0, \_downKeys.length); } if (key === 93 || key === 224) key = 91; if (key in \_mods) { \_mods\[key\] = false; for (const k in \_modifier) if (\_modifier\[k\] === key) hotkeys\[k\] = false; } } function unbind(keysInfo) { if (typeof keysInfo === "undefined") { Object.keys(\_handlers).forEach((key) => { Array.isArray(\_handlers\[key\]) && \_handlers\[key\].forEach((info) => eachUnbind(info)); delete \_handlers\[key\]; }); removeKeyEvent(null); } else if (Array.isArray(keysInfo)) { keysInfo.forEach((info) => { if (info.key) eachUnbind(info); }); } else if (typeof keysInfo === "object") { if (keysInfo.key) eachUnbind(keysInfo); } else if (typeof keysInfo === "string") { for (var \_len = arguments.length, args = new Array(\_len > 1 ? \_len - 1 : 0), \_key = 1; \_key < \_len; \_key++) { args\[\_key - 1\] = arguments\[\_key\]; } let \[scope, method\] = args; if (typeof scope === "function") { method = scope; scope = ""; } eachUnbind({ key: keysInfo, scope, method, splitKey: "+" }); } } var eachUnbind = (\_ref3) => { let { key, scope, method, splitKey = "+" } = \_ref3; const multipleKeys = getKeys(key); multipleKeys.forEach((originKey) => { const unbindKeys = originKey.split(splitKey); const len = unbindKeys.length; const lastKey = unbindKeys\[len - 1\]; const keyCode = lastKey === "\*" ? "\*" : code(lastKey); if (!\_handlers\[keyCode\]) return; if (!scope) scope = getScope(); const mods = len > 1 ? getMods(\_modifier, unbindKeys) : \[\]; const unbindElements = \[\]; \_handlers\[keyCode\] = \_handlers\[keyCode\].filter((record) => { const isMatchingMethod = method ? record.method === method : true; const isUnbind = isMatchingMethod && record.scope === scope && compareArray(record.mods, mods); if (isUnbind) unbindElements.push(record.element); return !isUnbind; }); unbindElements.forEach((element) => removeKeyEvent(element)); }); }; function eventHandler(event, handler, scope, element) { if (handler.element !== element) { return; } let modifiersMatch; if (handler.scope === scope || handler.scope === "all") { modifiersMatch = handler.mods.length > 0; for (const y in \_mods) { if (Object.prototype.hasOwnProperty.call(\_mods, y)) { if (!\_mods\[y\] && handler.mods.indexOf(+y) > -1 || \_mods\[y\] && handler.mods.indexOf(+y) === -1) { modifiersMatch = false; } } } if (handler.mods.length === 0 && !\_mods\[16\] && !\_mods\[18\] && !\_mods\[17\] && !\_mods\[91\] || modifiersMatch || handler.shortcut === "\*") { handler.keys = \[\]; handler.keys = handler.keys.concat(\_downKeys); if (handler.method(event, handler) === false) { if (event.preventDefault) event.preventDefault(); else event.returnValue = false; if (event.stopPropagation) event.stopPropagation(); if (event.cancelBubble) event.cancelBubble = true; } } } } function dispatch(event, element) { const asterisk = \_handlers\["\*"\]; let key = event.keyCode || event.which || event.charCode; if (!hotkeys.filter.call(this, event)) return; if (key === 93 || key === 224) key = 91; if (\_downKeys.indexOf(key) === -1 && key !== 229) \_downKeys.push(key); \["ctrlKey", "altKey", "shiftKey", "metaKey"\].forEach((keyName) => { const keyNum = modifierMap\[keyName\]; if (event\[keyName\] && \_downKeys.indexOf(keyNum) === -1) { \_downKeys.push(keyNum); } else if (!event\[keyName\] && \_downKeys.indexOf(keyNum) > -1) { \_downKeys.splice(\_downKeys.indexOf(keyNum), 1); } else if (keyName === "metaKey" && event\[keyName\] && \_downKeys.length === 3) { if (!(event.ctrlKey || event.shiftKey || event.altKey)) { \_downKeys = \_downKeys.slice(\_downKeys.indexOf(keyNum)); } } }); if (key in \_mods) { \_mods\[key\] = true; for (const k in \_modifier) { if (\_modifier\[k\] === key) hotkeys\[k\] = true; } if (!asterisk) return; } for (const e in \_mods) { if (Object.prototype.hasOwnProperty.call(\_mods, e)) { \_mods\[e\] = event\[modifierMap\[e\]\]; } } if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState("AltGraph")) { if (\_downKeys.indexOf(17) === -1) { \_downKeys.push(17); } if (\_downKeys.indexOf(18) === -1) { \_downKeys.push(18); } \_mods\[17\] = true; \_mods\[18\] = true; } const scope = getScope(); if (asterisk) { for (let i = 0; i < asterisk.length; i++) { if (asterisk\[i\].scope === scope && (event.type === "keydown" && asterisk\[i\].keydown || event.type === "keyup" && asterisk\[i\].keyup)) { eventHandler(event, asterisk\[i\], scope, element); } } } if (!(key in \_handlers)) return; const handlerKey = \_handlers\[key\]; const keyLen = handlerKey.length; for (let i = 0; i < keyLen; i++) { if (event.type === "keydown" && handlerKey\[i\].keydown || event.type === "keyup" && handlerKey\[i\].keyup) { if (handlerKey\[i\].key) { const record = handlerKey\[i\]; const { splitKey } = record; const keyShortcut = record.key.split(splitKey); const \_downKeysCurrent = \[\]; for (let a = 0; a < keyShortcut.length; a++) { \_downKeysCurrent.push(code(keyShortcut\[a\])); } if (\_downKeysCurrent.sort().join("") === \_downKeys.sort().join("")) { eventHandler(event, record, scope, element); } } } } } function hotkeys(key, option, method) { \_downKeys = \[\]; const keys = getKeys(key); let mods = \[\]; let scope = "all"; let element = document; let i = 0; let keyup = false; let keydown = true; let splitKey = "+"; let capture = false; let single = false; if (method === void 0 && typeof option === "function") { method = option; } if (Object.prototype.toString.call(option) === "\[object Object\]") { if (option.scope) scope = option.scope; if (option.element) element = option.element; if (option.keyup) keyup = option.keyup; if (option.keydown !== void 0) keydown = option.keydown; if (option.capture !== void 0) capture = option.capture; if (typeof option.splitKey === "string") splitKey = option.splitKey; if (option.single === true) single = true; } if (typeof option === "string") scope = option; if (single) unbind(key, scope); for (; i < keys.length; i++) { key = keys\[i\].split(splitKey); mods = \[\]; if (key.length > 1) mods = getMods(\_modifier, key); key = key\[key.length - 1\]; key = key === "\*" ? "\*" : code(key); if (!(key in \_handlers)) \_handlers\[key\] = \[\]; \_handlers\[key\].push({ keyup, keydown, scope, mods, shortcut: keys\[i\], method, key: keys\[i\], splitKey, element }); } if (typeof element !== "undefined" && window) { if (!elementEventMap.has(element)) { const keydownListener = function() { let event = arguments.length > 0 && arguments\[0\] !== void 0 ? arguments\[0\] : window.event; return dispatch(event, element); }; const keyupListenr = function() { let event = arguments.length > 0 && arguments\[0\] !== void 0 ? arguments\[0\] : window.event; dispatch(event, element); clearModifier(event); }; elementEventMap.set(element, { keydownListener, keyupListenr, capture }); addEvent(element, "keydown", keydownListener, capture); addEvent(element, "keyup", keyupListenr, capture); } if (!winListendFocus) { const listener = () => { \_downKeys = \[\]; }; winListendFocus = { listener, capture }; addEvent(window, "focus", listener, capture); } } } function trigger(shortcut) { let scope = arguments.length > 1 && arguments\[1\] !== void 0 ? arguments\[1\] : "all"; Object.keys(\_handlers).forEach((key) => { const dataList = \_handlers\[key\].filter((item) => item.scope === scope && item.shortcut === shortcut); dataList.forEach((data) => { if (data && data.method) { data.method(); } }); }); } function removeKeyEvent(element) { const values = Object.values(\_handlers).flat(); const findindex = values.findIndex((\_ref4) => { let { element: el } = \_ref4; return el === element; }); if (findindex < 0) { const { keydownListener, keyupListenr, capture } = elementEventMap.get(element) || {}; if (keydownListener && keyupListenr) { removeEvent(element, "keyup", keyupListenr, capture); removeEvent(element, "keydown", keydownListener, capture); elementEventMap.delete(element); } } if (values.length <= 0 || elementEventMap.size <= 0) { const eventKeys = Object.keys(elementEventMap); eventKeys.forEach((el) => { const { keydownListener, keyupListenr, capture } = elementEventMap.get(el) || {}; if (keydownListener && keyupListenr) { removeEvent(el, "keyup", keyupListenr, capture); removeEvent(el, "keydown", keydownListener, capture); elementEventMap.delete(el); } }); elementEventMap.clear(); Object.keys(\_handlers).forEach((key) => delete \_handlers\[key\]); if (winListendFocus) { const { listener, capture } = winListendFocus; removeEvent(window, "focus", listener, capture); winListendFocus = null; } } } var \_api = { getPressedKeyString, setScope, getScope, deleteScope, getPressedKeyCodes, getAllKeyCodes, isPressed, filter, trigger, unbind, keyMap: \_keyMap, modifier: \_modifier, modifierMap }; for (const a in \_api) { if (Object.prototype.hasOwnProperty.call(\_api, a)) { hotkeys\[a\] = \_api\[a\]; } } if (typeof window !== "undefined") { const \_hotkeys = window.hotkeys; hotkeys.noConflict = (deep) => { if (deep && window.hotkeys === hotkeys) { window.hotkeys = \_hotkeys; } return hotkeys; }; window.hotkeys = hotkeys; } // src/render/inspector/utils/highlight.ts var iframesListeningTo = /\* @\_\_PURE\_\_ \*/ new Set(); function setupHighlighter(handlers) { function startInspectingNative() { registerListenersOnWindow(window); } function registerListenersOnWindow(window2) { if (window2 && typeof window2.addEventListener === "function") { window2.addEventListener("click", onClick, true); window2.addEventListener("mousedown", onMouseEvent, true); window2.addEventListener("mouseover", onMouseEvent, true); window2.addEventListener("mouseup", onMouseEvent, true); window2.addEventListener("pointerdown", onPointerDown, true); window2.addEventListener("pointerover", onPointerOver, true); window2.addEventListener("pointerup", onPointerUp, true); } } function stopInspectingNative() { removeListenersOnWindow(window); iframesListeningTo.forEach(function(frame) { try { removeListenersOnWindow(frame.contentWindow); } catch (error) {} }); iframesListeningTo = /\* @\_\_PURE\_\_ \*/ new Set(); } function removeListenersOnWindow(window2) { if (window2 && typeof window2.removeEventListener === "function") { window2.removeEventListener("click", onClick, true); window2.removeEventListener("mousedown", onMouseEvent, true); window2.removeEventListener("mouseover", onMouseEvent, true); window2.removeEventListener("mouseup", onMouseEvent, true); window2.removeEventListener("pointerdown", onPointerDown, true); window2.removeEventListener("pointerover", onPointerOver, true); window2.removeEventListener("pointerup", onPointerUp, true); } } function onClick(event) { event.preventDefault(); event.stopPropagation(); stopInspectingNative(); handlers.onClick?.(event.target); } function onMouseEvent(event) { event.preventDefault(); event.stopPropagation(); } function onPointerDown(event) { event.preventDefault(); event.stopPropagation(); } function onPointerOver(event) { event.preventDefault(); event.stopPropagation(); const target = event.target; if (target.tagName === "IFRAME") { const iframe = target; try { if (!iframesListeningTo.has(iframe)) { const window2 = iframe.contentWindow; registerListenersOnWindow(window2); iframesListeningTo.add(iframe); } } catch (error) {} } handlers.onPointerOver?.(event.target); } function onPointerUp(event) { event.preventDefault(); event.stopPropagation(); } startInspectingNative(); return stopInspectingNative; } // src/render/inspector/utils/inspect.ts var import\_querystring = \_\_toESM(require\_querystring(), 1); // src/render/inspector/utils/fiber.ts var isNativeTagFiber = (fiber) => typeof fiber?.type === "string"; var isReactSymbolFiber = (fiber) => typeof fiber?.type?.$typeof === "symbol"; var isForwardRef = (fiber) => fiber?.type?.$typeof === Symbol.for("react.forward\_ref"); var getElementFiber = (element) => { const fiberKey = Object.keys(element.dataset).find((key) => key.startsWith("source-")); if (fiberKey) { const source = window.debug\[\`data-${fiberKey}\`\].\_\_source; return { pendingProps: source ? { "data-inspector-line": source.lineNumber, "data-inspector-column": source.columnNumber, "data-inspector-relative-path": source.fileName } : void 0, \_debugSource: source }; } return void 0; }; var getElementFiberUpward = (element) => { if (!element) return void 0; const fiber = getElementFiber(element); if (fiber) return fiber; return getElementFiberUpward(element.parentElement); }; var getDirectParentFiber = (child) => { let current = child.return; while (current) { if (!isReactSymbolFiber(current)) { return current; } current = current.return; } return null; }; var getFiberName = (fiber) => { const fiberType = fiber?.type; if (!fiberType) return void 0; const { displayName, name } = fiberType; if (typeof displayName === "string") { return displayName; } else if (typeof name === "string") { return name; } return void 0; }; // src/render/inspector/utils/inspect.ts var getCodeInfoFromDebugSource = (fiber) => { if (!fiber?.\_debugSource) return void 0; const { fileName, lineNumber, columnNumber } = fiber.\_debugSource; if (fileName && lineNumber) { return { lineNumber: String(lineNumber), columnNumber: String(columnNumber ?? 1), absolutePath: fileName.match(/^<.\*>$/) ? fileName.replace(/^<|>$/g, "") : fileName }; } return void 0; }; var getCodeInfoFromProps = (fiber) => { if (!fiber?.pendingProps) return void 0; const { "data-inspector-line": lineNumber, "data-inspector-column": columnNumber, "data-inspector-relative-path": relativePath } = fiber.pendingProps; if (lineNumber && columnNumber && relativePath) { return { lineNumber, columnNumber, relativePath }; } return void 0; }; var getCodeInfoFromFiber = (fiber) => getCodeInfoFromProps(fiber) ?? getCodeInfoFromDebugSource(fiber); var getReferenceFiber = (baseFiber) => { if (!baseFiber) return void 0; const directParent = getDirectParentFiber(baseFiber); if (!directParent) return void 0; const isParentNative = isNativeTagFiber(directParent); const isOnlyOneChild = !directParent.child.sibling; let referenceFiber = !isParentNative && isOnlyOneChild ? directParent : baseFiber; const originReferenceFiber = referenceFiber; while (referenceFiber) { if (getCodeInfoFromFiber(referenceFiber)) return referenceFiber; referenceFiber = referenceFiber.return; } return originReferenceFiber; }; var getElementCodeInfo = (element) => { const fiber = getElementFiberUpward(element); return getCodeInfoFromFiber(fiber); }; var gotoEditor = (source) => { if (!source) return; const { lineNumber, columnNumber, relativePath, absolutePath } = source; const isRelative = Boolean(relativePath); const launchParams = { file: (isRelative ? relativePath : absolutePath) + \`:${lineNumber}:${columnNumber}\`, lineNumber, colNumber: columnNumber }; const apiRoute = isRelative ? \`/\_\_open-in-editor/relative\` : \`/\_\_open-in-editor\`; fetch(\`${apiRoute}?${import\_querystring.default.stringify(launchParams)}\`); }; var getNamedFiber = (baseFiber) => { let fiber = baseFiber; let originNamedFiber; while (fiber) { let parent = fiber.return ?? void 0; let forwardParent; while (isReactSymbolFiber(parent)) { if (isForwardRef(parent)) { forwardParent = parent; } parent = parent?.return ?? void 0; } if (forwardParent) { fiber = forwardParent; } if (getFiberName(fiber)) { if (!originNamedFiber) originNamedFiber = fiber; if (getCodeInfoFromFiber(fiber)) return fiber; } fiber = parent; } return originNamedFiber; }; var getElementInspect = (element) => { const fiber = getElementFiberUpward(element); const referenceFiber = getReferenceFiber(fiber); const namedFiber = getNamedFiber(referenceFiber); const fiberName = getFiberName(namedFiber); const nodeName = element.nodeName.toLowerCase(); const title = fiberName ? \`${nodeName} in <${fiberName}>\` : nodeName; return { fiber: referenceFiber, name: fiberName, title }; }; // src/render/inspector/utils/overlay.ts function getNestedBoundingClientRect(node) { return node.getBoundingClientRect(); } function getElementDimensions(domElement) { const calculatedStyle = window.getComputedStyle(domElement); return { borderLeft: parseInt(calculatedStyle.borderLeftWidth, 10), borderRight: parseInt(calculatedStyle.borderRightWidth, 10), borderTop: parseInt(calculatedStyle.borderTopWidth, 10), borderBottom: parseInt(calculatedStyle.borderBottomWidth, 10), marginLeft: parseInt(calculatedStyle.marginLeft, 10), marginRight: parseInt(calculatedStyle.marginRight, 10), marginTop: parseInt(calculatedStyle.marginTop, 10), marginBottom: parseInt(calculatedStyle.marginBottom, 10), paddingLeft: parseInt(calculatedStyle.paddingLeft, 10), paddingRight: parseInt(calculatedStyle.paddingRight, 10), paddingTop: parseInt(calculatedStyle.paddingTop, 10), paddingBottom: parseInt(calculatedStyle.paddingBottom, 10) }; } // src/render/inspector/Overlay.tsx var OverlayRect = class { constructor(doc, container) { \_\_publicField(this, "node"); \_\_publicField(this, "border"); \_\_publicField(this, "padding"); \_\_publicField(this, "content"); this.node = doc.createElement("div"); this.border = doc.createElement("div"); this.padding = doc.createElement("div"); this.content = doc.createElement("div"); this.border.style.borderColor = overlayStyles.border; this.padding.style.borderColor = overlayStyles.padding; this.content.style.backgroundColor = overlayStyles.background; Object.assign(this.node.style, { borderColor: overlayStyles.margin, pointerEvents: "none", position: "fixed" }); this.node.style.zIndex = "10000000"; this.node.appendChild(this.border); this.border.appendChild(this.padding); this.padding.appendChild(this.content); container.prepend(this.node); } remove() { if (this.node.parentNode) { this.node.parentNode.removeChild(this.node); } } update(box, dims) { boxWrap(dims, "margin", this.node); boxWrap(dims, "border", this.border); boxWrap(dims, "padding", this.padding); Object.assign(this.content.style, { height: \`${box.height - dims.borderTop - dims.borderBottom - dims.paddingTop - dims.paddingBottom}px\`, width: \`${box.width - dims.borderLeft - dims.borderRight - dims.paddingLeft - dims.paddingRight}px\` }); Object.assign(this.node.style, { top: \`${box.top - dims.marginTop}px\`, left: \`${box.left - dims.marginLeft}px\` }); } }; var OverlayTip = class { constructor(doc, container) { \_\_publicField(this, "tip"); \_\_publicField(this, "nameSpan"); \_\_publicField(this, "titleDiv"); \_\_publicField(this, "infoDiv"); \_\_publicField(this, "dimSpan"); this.tip = doc.createElement("div"); Object.assign(this.tip.style, { display: "flex", flexFlow: "row nowrap", alignItems: "center", backgroundColor: "#333740", borderRadius: "2px", fontFamily: '"SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace', fontWeight: "bold", padding: "6px 8px", pointerEvents: "none", position: "fixed", fontSize: "12px", whiteSpace: "nowrap" }); this.nameSpan = doc.createElement("span"); this.tip.appendChild(this.nameSpan); Object.assign(this.nameSpan.style, { display: "flex", flexDirection: "column", borderRight: "1px solid #aaaaaa", paddingRight: "0.8rem", marginRight: "0.8rem" }); this.titleDiv = doc.createElement("div"); this.nameSpan.appendChild(this.titleDiv); Object.assign(this.titleDiv.style, { color: "#ee78e6", fontSize: "16px" }); this.infoDiv = doc.createElement("div"); this.nameSpan.appendChild(this.infoDiv); Object.assign(this.infoDiv.style, { color: "#ee78e6", fontSize: "14px" }); this.dimSpan = doc.createElement("span"); this.tip.appendChild(this.dimSpan); Object.assign(this.dimSpan.style, { color: "#d7d7d7" }); this.tip.style.zIndex = "10000000"; container.appendChild(this.tip); } remove() { if (this.tip.parentNode) { this.tip.parentNode.removeChild(this.tip); } } updateText(name, info, width, height) { this.titleDiv.textContent = name; this.infoDiv.textContent = info ?? ""; this.dimSpan.textContent = \`${Math.round(width)}px \\xD7 ${Math.round(height)}px\`; } updatePosition(dims, bounds) { const tipRect = this.tip.getBoundingClientRect(); const tipPos = findTipPos(dims, bounds, { width: tipRect.width, height: tipRect.height }); Object.assign(this.tip.style, tipPos.style); } }; var Overlay = class { constructor() { \_\_publicField(this, "window"); \_\_publicField(this, "tipBoundsWindow"); \_\_publicField(this, "container"); \_\_publicField(this, "tip"); \_\_publicField(this, "rects"); \_\_publicField(this, "removeCallback"); const currentWindow = window.\_\_REACT\_DEVTOOLS\_TARGET\_WINDOW\_\_ || window; this.window = currentWindow; const tipBoundsWindow = window.\_\_REACT\_DEVTOOLS\_TARGET\_WINDOW\_\_ || window; this.tipBoundsWindow = tipBoundsWindow; const doc = currentWindow.document; this.container = doc.createElement("div"); this.container.style.zIndex = "10000000"; this.tip = new OverlayTip(doc, this.container); this.rects = \[\]; this.removeCallback = () => {}; doc.body.appendChild(this.container); } remove() { this.tip.remove(); this.rects.forEach((rect) => { rect.remove(); }); this.rects.length = 0; if (this.container.parentNode) { this.container.parentNode.removeChild(this.container); } this.removeCallback(); } setRemoveCallback(callback) { this.removeCallback = callback.bind(this); } inspect(nodes, name, info) { const elements = nodes.filter((node) => node.nodeType === Node.ELEMENT\_NODE); while (this.rects.length > elements.length) { const rect = this.rects.pop(); rect?.remove(); } if (elements.length === 0) { return; } while (this.rects.length < elements.length) { this.rects.push(new OverlayRect(this.window.document, this.container)); } const outerBox = { top: Number.POSITIVE\_INFINITY, right: Number.NEGATIVE\_INFINITY, bottom: Number.NEGATIVE\_INFINITY, left: Number.POSITIVE\_INFINITY }; elements.forEach((element, index) => { const box = getNestedBoundingClientRect(element, this.window); const dims = getElementDimensions(element); outerBox.top = Math.min(outerBox.top, box.top - dims.marginTop); outerBox.right = Math.max( outerBox.right, box.left + box.width + dims.marginRight ); outerBox.bottom = Math.max( outerBox.bottom, box.top + box.height + dims.marginBottom ); outerBox.left = Math.min(outerBox.left, box.left - dims.marginLeft); const rect = this.rects\[index\]; rect.update(box, dims); }); if (!name) { name = elements\[0\].nodeName.toLowerCase(); const node = elements\[0\]; const hook = node.ownerDocument.defaultView?.\_\_REACT\_DEVTOOLS\_GLOBAL\_HOOK\_\_; if (hook?.rendererInterfaces) { let ownerName = null; for (const rendererInterface of hook.rendererInterfaces.values()) { const id = rendererInterface.getFiberIDForNative(node, true); if (id !== null) { ownerName = rendererInterface.getDisplayNameForFiberID(id, true); break; } } if (ownerName) { name += \` (in ${ownerName})\`; } } } this.tip.updateText( name, info, outerBox.right - outerBox.left, outerBox.bottom - outerBox.top ); const tipBounds = getNestedBoundingClientRect( this.tipBoundsWindow.document.documentElement, this.window ); this.tip.updatePosition({ top: outerBox.top, left: outerBox.left, height: outerBox.bottom - outerBox.top, width: outerBox.right - outerBox.left }, { top: tipBounds.top + this.tipBoundsWindow.scrollY, left: tipBounds.left + this.tipBoundsWindow.scrollX, height: this.tipBoundsWindow.innerHeight, width: this.tipBoundsWindow.innerWidth }); } }; function findTipPos(dims, bounds, tipSize) { const tipHeight = Math.max(tipSize.height, 20); const tipWidth = Math.max(tipSize.width, 60); const margin = 5; let top; if (dims.top + dims.height + tipHeight <= bounds.top + bounds.height) { if (dims.top + dims.height < bounds.top + 0) { top = bounds.top + margin; } else { top = dims.top + dims.height + margin; } } else if (dims.top - tipHeight <= bounds.top + bounds.height) { if (dims.top - tipHeight - margin < bounds.top + margin) { top = bounds.top + margin; } else { top = dims.top - tipHeight - margin; } } else { top = bounds.top + bounds.height - tipHeight - margin; } let left = dims.left + margin; if (dims.left < bounds.left) { left = bounds.left + margin; } if (dims.left + tipWidth > bounds.left + bounds.width) { left = bounds.left + bounds.width - tipWidth - margin; } return { style: { top: \`${top}px\`, left: \`${left}px\` } }; } function boxWrap(dims, what, node) { Object.assign(node.style, { borderTopWidth: \`${dims\[\`${what}Top\`\]}px\`, borderLeftWidth: \`${dims\[\`${what}Left\`\]}px\`, borderRightWidth: \`${dims\[\`${what}Right\`\]}px\`, borderBottomWidth: \`${dims\[\`${what}Bottom\`\]}px\`, borderStyle: "solid" }); } var overlayStyles = { background: "rgba(120, 170, 210, 0.7)", padding: "rgba(77, 200, 0, 0.3)", margin: "rgba(255, 155, 0, 0.3)", border: "rgba(255, 200, 50, 0.3)" }; // src/render/inspector/mounted.ts function createRef(init) { return { current: init }; } var defaultHotKeys = \["control", "shift", "command", "c"\]; var hotkey = defaultHotKeys.join("+"); var overlayRef = createRef(); var mousePointRef = createRef({ x: 0, y: 0 }); var recordMousePoint = ({ clientX, clientY }) => { mousePointRef.current.x = clientX; mousePointRef.current.y = clientY; }; var startInspect = () => { const overlay = new Overlay(); overlayRef.current = overlay; const stopCallback = setupHighlighter({ onPointerOver: handleHoverElement, onClick: handleClickElement }); overlay.setRemoveCallback(stopCallback); const initPoint = mousePointRef.current; const initElement = document.elementFromPoint(initPoint.x, initPoint.y); if (initElement) handleHoverElement(initElement); }; var stopInspect = () => { overlayRef.current?.remove(); overlayRef.current = void 0; }; var handleHoverElement = (element) => { const overlay = overlayRef.current; const codeInfo = getElementCodeInfo(element); const relativePath = codeInfo?.relativePath; const absolutePath = codeInfo?.absolutePath; const { fiber, name, title } = getElementInspect(element); overlay?.inspect?.(\[element\], title, relativePath ?? absolutePath); console.log("hover", fiber, name); }; var handleClickElement = (element) => { stopInspect(); const codeInfo = getElementCodeInfo(element); const { fiber, name } = getElementInspect(element); console.log("codeInfo", codeInfo); gotoEditor(codeInfo); console.log("hover", fiber, name); }; document.addEventListener("mousemove", recordMousePoint, true); var handleHotKeys = (event, handler) => { if (handler.key === hotkey) { overlayRef.current ? stopInspect() : startInspect(); } else if (handler.key === "esc" && overlayRef.current) { stopInspect(); } }; hotkeys(\`${hotkey}, esc\`, handleHotKeys); window.\_\_REACT\_DEV\_INSPECTOR\_TOGGLE\_\_ = () => overlayRef.current ? stopInspect() : startInspect(); })();; window.debug = { "data-source-1536": { "\_\_source": {} } }